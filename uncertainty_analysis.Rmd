Title: Uncertainty Analysis
Authors: Bruce Chidley, Sophie Stelmach, Lauren Farrell, Thaneswary Rajanderan, Geneva Liwag

This R Markdown file goes through uncertainty analysis for the model created in the main file. Similar in structure, but parameters are varied according to their distributions.
```{r}
require(deSolve)

mod5=function(t, y, parms){
  #Pull state variables from y vector
  L = y[1]
  Ns = y[2]
  Ni = y[3]
  A = y[4]
  Hs = y[5]
  Hi = y[6]
  Hr = y[7]
  
  #Pull the required parameter values from the parms vector
  b_l=parms["b_l"]
  b_n=parms["b_n"]
  r=parms["r"]
  a=parms["a"]
  delta=parms["delta"]
  mu_l=parms["mu_l"]
  mu_n=parms["mu_n"]
  mu_a=parms["mu_a"]
  mu_h=parms["mu_h"]
  beta=parms["beta"]
  gamma=parms["gamma"]
  gamma_h=parms["gamma_h"]
  p_hl=parms["p_hl"]
  p_nh=parms["p_nh"]
  p_hn = parms["p_hn"]
  
  #c=(1-(1-delta)*(exp(Ni/((1-r)*(Hs+Hi+Hr)))))
  
  dL = beta*A*exp(-gamma*A) - b_l*L*(1-r) - mu_l*L
    
  dNs = b_l*L*(1-r)*(1-a)*(1- 
       (1- (1-delta)^((Ni/((1-r)*(Hs+Hi+Hr)
                          )
                       )
                     )
       )
    )*((Hs + (1-p_hl)*Hi + Hr)/(Hs+Hi+Hr)) 
  - b_n*Ns*(1-r) - mu_n*Ns
    
  dNi = b_l*L*(1-r)*(1-a)*p_hl*(Hi/(Hs+Hi+Hr)) + b_l*L*(1-r)*(1-a)*( 
       (1- (1-delta)^((Ni/((1-r)*(Hs+Hi+Hr)
                          )
                       )
                     )
       )
    ) *((Hs + (1-p_hl)*Hi + Hr)/(Hs+Hi+Hr)) - b_n*Ni*(1-r) - mu_n*Ni
    
  dA = b_n*(Ns+Ni)*(1-r)*(1-a) - mu_a*A
  
  dHs = mu_h*(Hs+Hi+Hr) - b_n*p_nh*(1-r)*Ni*(Hs/(Hs+Hi+Hr)) - mu_h*Hs
    
  dHi = b_n*p_nh*(1-r)*Ni*(Hs/(Hs+Hi+Hr)) - gamma_h*Hi - mu_h*Hi
    
  dHr = gamma_h*Hi - mu_h*Hr
  
  res=c(dL, dNs, dNi, dA, dHs, dHi, dHr)
  list(res)
}

```


Nearly all parameters are set to have a normal distribution, due to a lack of evidence otherwise
```{r}
times  = seq(0, 120, by=1)

b_l=rnorm(1000,0.5,0.005)
  b_n=rnorm(1000,0.5,0.005)
  r=rep(0, 1000)
  a=rnorm(1000,0.8,0.005)
  delta=rnorm(1000,0.7,0.008)
  mu_l=rnorm(1000,0.01,0.005)
  mu_n=rnorm(1000,0.002,0.0005)
  mu_a=rnorm(1000,0.1,0.01)
  mu_h=rnorm(1000,0.001,0.0005)
  beta=rnorm(1000,15,0.3)
  gamma=rnorm(1000,0.00005,0.0000001)
  gamma_h=rnorm(1000,0.1,0.0005)
  p_hl=rnorm(1000,0.8,0.03)
  p_nh=rnorm(1000,0.9,0.03)
  p_hn=rnorm(1000,0.8,0.03)
  
  param_matrix = cbind(b_l,b_n,r,a,delta,mu_l,mu_n,mu_a,mu_h,beta,gamma,gamma_h,p_hl,p_nh,p_hn)
  

start = c(L=5000, Ns=2000, Ni=1000, A=500, Hs=400, Hi=1000, Hr=100)
```


A matrix containing maximum and minimum values over a set of 1000 parameter combinations is created, which will then be graphed and analyzed.
```{r}
out = ode(y = start, times = times, func = mod5, 
     parms = param_matrix[1,])
out=as.data.frame(out)
 
 t = out$time
 max_L = out$L
 min_L = out$L
 max_Ns = out$Ns
 min_Ns = out$Ns
 max_Ni = out$Ni
 min_Ni = out$Ni
 max_A = out$A
 min_A = out$A
 max_Hs = out$Hs
 min_Hs = out$Hs
 max_Hi = out$Hi
 min_Hi = out$Hi
 max_Hr = out$Hr
 min_Hr = out$Hr
 
 #Creates the matrix according to the output of the first combination of parameters
 stat_matrix = cbind(t, max_L, min_L, max_Ns, min_Ns, max_Ni, min_Ni, max_A, min_A, max_Hs, min_Hs, max_Hi, min_Hi, max_Hr, min_Hr)
 stat_matrix = as.data.frame(stat_matrix)
 
 #Performs the rest of the ODE operations, and the values replace the ones in stat_matrix if they are larger or smaller where applicable
 for (i in 2:nrow(param_matrix)){
   
   out = ode(y = start, times = times, func = mod5, 
             parms = param_matrix[i,])
   out=as.data.frame(out)
   
   for (k in 1:nrow(out)){
     stat_matrix$max_L[k] = max(out$L[k], stat_matrix$max_L[k])
     stat_matrix$min_L[k] = min(out$L[k], stat_matrix$min_L[k])
     stat_matrix$max_Ns[k] = max(out$Ns[k], stat_matrix$max_Ns[k])
     stat_matrix$min_Ns[k] = min(out$Ns[k], stat_matrix$min_Ns[k])
     stat_matrix$max_Ni[k] = max(out$Ni[k], stat_matrix$max_Ni[k])
     stat_matrix$min_Ni[k] = min(out$Ni[k], stat_matrix$min_Ni[k])
     stat_matrix$max_A[k] = max(out$A[k], stat_matrix$max_A[k])
     stat_matrix$min_A[k] = min(out$A[k], stat_matrix$min_A[k])
     stat_matrix$max_Hs[k] = max(out$Hs[k], stat_matrix$max_Hs[k])
     stat_matrix$min_Hs[k] = min(out$Hs[k], stat_matrix$min_Hs[k])
     stat_matrix$max_Hi[k] = max(out$Hi[k], stat_matrix$max_Hi[k])
     stat_matrix$min_Hi[k] = min(out$Hi[k], stat_matrix$min_Hi[k])
     stat_matrix$max_Hr[k] = max(out$Hr[k], stat_matrix$max_Hr[k])
     stat_matrix$min_Hr[k] = min(out$Hr[k], stat_matrix$min_Hr[k])
   }
   
 }
head(out)
```

Max and Min values are plotted, showing an approximate range that values may lie in if parameter values vary
```{r}
plot(x = out$time, y = stat_matrix$min_L, col = "black", ylab = "Number of individuals", 
      xlab = "Time (days)", type = "l", xlim = c(0, 120), ylim = c(0,200000))
 lines(x = out$time, y = stat_matrix$min_Ns, col = "red")
 lines(x = out$time, y = stat_matrix$min_A, col = "purple")
 lines(x = out$time, y = stat_matrix$min_Hi, col = "magenta")
 lines(x = out$time, y = stat_matrix$min_Ni, col = "pink")
 lines(x = out$time, y = stat_matrix$min_Hr, col = "green")
 lines(x = out$time, y = stat_matrix$min_Hs, col = "cornflowerblue")
 
 lines(x = out$time, y = stat_matrix$max_L, col = "black")
 lines(x = out$time, y = stat_matrix$max_Ns, col = "red")
 lines(x = out$time, y = stat_matrix$max_A, col = "purple")
 lines(x = out$time, y = stat_matrix$max_Hi, col = "magenta")
 lines(x = out$time, y = stat_matrix$max_Ni, col = "pink")
 lines(x = out$time, y = stat_matrix$max_Hr, col = "green")
 lines(x = out$time, y = stat_matrix$max_Hs, col = "cornflowerblue")
 
 tail(out)

```
